<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maoni Personality人格类型测试（Inspired by MBTI）</title>
  </head>
  <body>
    <div id="root"></div>
    <!-- NFC verification override (only when URL has picc_data & cmac) -->
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script>
    <script>
      ;(() => {
        const hasParams = (() => {
          try {
            const u = new URL(window.location.href)
            return u.searchParams.has('picc_data') && u.searchParams.has('cmac')
          } catch {
            return false
          }
        })()
        if (!hasParams) return

        // Stop normal app render; main.jsx will respect this flag.
        window.__NFC_OVERRIDE__ = true

        const KEY_HEX = '00000000000000000000000000000000' // 16 bytes all-zero
        const LS_KEY = 'last_nfc_counter'

        const $root = document.getElementById('root')
        if ($root) $root.innerHTML = ''

        function normalizeHex(s) {
          return (s || '')
            .trim()
            .toLowerCase()
            .replace(/^0x/, '')
            .replace(/[^0-9a-f]/g, '')
        }
        function isHexLike(s) {
          const h = normalizeHex(s)
          return h.length > 0 && h.length % 2 === 0 && /^[0-9a-f]+$/.test(h)
        }
        function hexToU8(hex) {
          const h = normalizeHex(hex)
          const out = new Uint8Array(h.length / 2)
          for (let i = 0; i < out.length; i++) out[i] = parseInt(h.slice(i * 2, i * 2 + 2), 16)
          return out
        }
        function u8ToHex(u8) {
          let s = ''
          for (let i = 0; i < u8.length; i++) s += (u8[i] & 0xff).toString(16).padStart(2, '0')
          return s
        }
        function b64ToU8(b64) {
          let s = (b64 || '').replace(/-/g, '+').replace(/_/g, '/')
          while (s.length % 4 !== 0) s += '='
          const raw = atob(s)
          const out = new Uint8Array(raw.length)
          for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i)
          return out
        }
        function parseParamBytes(v) {
          if (isHexLike(v)) return hexToU8(v)
          return b64ToU8(v)
        }
        function u8ToWA(u8) {
          const words = []
          for (let i = 0; i < u8.length; i++) words[(i / 4) | 0] |= u8[i] << (24 - 8 * (i % 4))
          return CryptoJS.lib.WordArray.create(words, u8.length)
        }
        function waToU8(wa) {
          const out = new Uint8Array(wa.sigBytes)
          for (let i = 0; i < wa.sigBytes; i++) out[i] = (wa.words[(i / 4) | 0] >>> (24 - 8 * (i % 4))) & 0xff
          return out
        }

        // AES-128-CBC decrypt (IV=0, NoPadding) for NTAG 424 DNA PICCData (common SDM layout)
        function aesCbcDec(cipherU8, keyU8) {
          const key = u8ToWA(keyU8)
          const iv = CryptoJS.lib.WordArray.create([0, 0, 0, 0], 16)
          const ct = u8ToWA(cipherU8)
          const pt = CryptoJS.AES.decrypt({ ciphertext: ct }, key, {
            iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.NoPadding,
          })
          return waToU8(pt)
        }

        // AES-ECB encrypt single 16-byte block (NoPadding)
        function aesEcbEncBlock16(block16U8, keyU8) {
          const key = u8ToWA(keyU8)
          const pt = u8ToWA(block16U8)
          const enc = CryptoJS.AES.encrypt(pt, key, {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.NoPadding,
            iv: CryptoJS.lib.WordArray.create(),
          })
          return waToU8(enc.ciphertext)
        }

        // AES-CMAC (RFC 4493)
        function xor16(a, b) {
          const o = new Uint8Array(16)
          for (let i = 0; i < 16; i++) o[i] = (a[i] ^ b[i]) & 0xff
          return o
        }
        function ls1(input) {
          const o = new Uint8Array(16)
          let carry = 0
          for (let i = 15; i >= 0; i--) {
            const v = input[i]
            o[i] = ((v << 1) & 0xff) | carry
            carry = (v & 0x80) ? 1 : 0
          }
          return o
        }
        function subkeys(keyU8) {
          const Rb = 0x87
          const L = aesEcbEncBlock16(new Uint8Array(16), keyU8)
          let K1 = ls1(L)
          if (L[0] & 0x80) K1[15] ^= Rb
          let K2 = ls1(K1)
          if (K1[0] & 0x80) K2[15] ^= Rb
          return { K1, K2 }
        }
        function pad10star(m) {
          const o = new Uint8Array(16)
          o.set(m, 0)
          o[m.length] = 0x80
          return o
        }
        function cmac(keyU8, msgU8) {
          const { K1, K2 } = subkeys(keyU8)
          const n0 = Math.ceil((msgU8.length || 0) / 16)
          const n = n0 === 0 ? 1 : n0
          const complete = msgU8.length > 0 && msgU8.length % 16 === 0
          let last
          if (complete) {
            const mLast = msgU8.slice((n - 1) * 16, n * 16)
            last = xor16(mLast, K1)
          } else {
            const part = msgU8.slice((n - 1) * 16)
            last = xor16(pad10star(part), K2)
          }
          let X = new Uint8Array(16)
          for (let i = 0; i < n - 1; i++) {
            const Mi = msgU8.slice(i * 16, (i + 1) * 16)
            X = aesEcbEncBlock16(xor16(X, Mi), keyU8)
          }
          return aesEcbEncBlock16(xor16(X, last), keyU8) // 16 bytes
        }

        // SUN: derive Ksdmmac then CMAC over picc_data, compare 8-byte truncation
        // Derivation vector (common): SV = 0x3C 00 01 00 80 00 || UID(7) || Counter(3)  => 16 bytes
        function deriveKsdmMac(masterKeyU8, uid7, ctr3) {
          const sv = new Uint8Array(16)
          sv.set([0x3c, 0x00, 0x01, 0x00, 0x80, 0x00], 0)
          sv.set(uid7, 6)
          sv.set(ctr3, 13)
          return aesEcbEncBlock16(sv, masterKeyU8)
        }

        function overlay(title, ok, lines) {
          const host = document.createElement('div')
          host.id = '__nfc_overlay__'
          host.style.cssText =
            'position:fixed;inset:0;z-index:2147483647;background:rgba(0,0,0,.55);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;padding:24px;'
          const card = document.createElement('div')
          card.style.cssText =
            'width:min(640px,92vw);background:rgba(255,255,255,.96);border-radius:18px;box-shadow:0 24px 80px rgba(0,0,0,.28);padding:18px 18px 14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"PingFang SC","Microsoft YaHei",sans-serif;'
          const h = document.createElement('div')
          h.textContent = title
          h.style.cssText = `font-size:18px;font-weight:800;margin:0 0 10px;color:${ok ? '#0f7a3b' : '#b42318'};`
          const pre = document.createElement('div')
          pre.textContent = (lines || []).join('\n')
          pre.style.cssText =
            'white-space:pre-wrap;word-break:break-word;font-size:13px;line-height:1.5;color:#111827;background:rgba(17,24,39,.04);border-radius:12px;padding:12px;'
          const row = document.createElement('div')
          row.style.cssText = 'display:flex;justify-content:flex-end;gap:10px;margin-top:12px;'
          const btn = document.createElement('button')
          btn.type = 'button'
          btn.textContent = '关闭'
          btn.style.cssText =
            'border:0;border-radius:12px;padding:10px 14px;background:#111827;color:#fff;cursor:pointer;font-weight:800;'
          btn.onclick = () => host.remove()
          row.appendChild(btn)
          card.appendChild(h)
          card.appendChild(pre)
          card.appendChild(row)
          host.appendChild(card)
          host.addEventListener('click', (e) => {
            if (e.target === host) host.remove()
          })
          document.body.appendChild(host)
        }

        function run() {
          const u = new URL(window.location.href)
          const piccRaw = u.searchParams.get('picc_data')
          const cmacRaw = u.searchParams.get('cmac')
          const picc = parseParamBytes(piccRaw)
          const cmacParam = parseParamBytes(cmacRaw)
          const cmac8 = cmacParam.length >= 8 ? cmacParam.slice(0, 8) : cmacParam
          const key = hexToU8(KEY_HEX)

          if (picc.length % 16 !== 0) {
            overlay('NFC 验证失败', false, [
              'picc_data 长度不是 16 的倍数（AES-CBC NoPadding 需要整块）。',
              `picc_data_len=${picc.length}`,
            ])
            return
          }

          const plain = aesCbcDec(picc, key)
          if (plain.length < 10) {
            overlay('NFC 验证失败', false, [
              '解密结果长度不足（需要至少 10 字节：UID(7) + Counter(3)）。',
              `plain_len=${plain.length}`,
            ])
            return
          }

          const uid = plain.slice(0, 7)
          const ctr3 = plain.slice(7, 10)
          const counter = ctr3[0] | (ctr3[1] << 8) | (ctr3[2] << 16) // LSB little-endian

          const last = parseInt(localStorage.getItem(LS_KEY) || '0', 10)
          const antiReplayOk = counter > last

          const ksdmMac = deriveKsdmMac(key, uid, ctr3)
          const mac16 = cmac(ksdmMac, picc)
          const mac8 = mac16.slice(0, 8)
          const macOk = u8ToHex(mac8) === u8ToHex(cmac8)

          const ok = antiReplayOk && macOk
          if (ok) localStorage.setItem(LS_KEY, String(counter))

          overlay(ok ? 'NFC 实物验证成功' : 'NFC 实物验证失败', ok, [
            `UID(7B): ${u8ToHex(uid)}`,
            `Counter(3B LSB): ${u8ToHex(ctr3)}  =>  ${counter}`,
            `CMAC8(url): ${u8ToHex(cmac8)}`,
            `CMAC8(calc): ${u8ToHex(mac8)}`,
            `验签: ${macOk ? 'OK' : 'FAIL'}`,
            `防重放: ${antiReplayOk ? 'OK' : `FAIL (last=${last})`}`,
          ])
        }

        try {
          if (!window.CryptoJS) throw new Error('crypto-js 未加载')
          run()
        } catch (e) {
          overlay('NFC 验证失败', false, [
            '脚本异常：' + (e && e.message ? e.message : String(e)),
            e && e.stack ? '\n' + e.stack : '',
          ])
        }
      })()
    </script>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
